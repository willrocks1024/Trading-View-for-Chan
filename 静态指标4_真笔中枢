//@version=6
indicator("合并K线与分型标记（真笔+中枢延续）", overlay=true)

// ---------- 自定义结构体 ----------
type Pen
    int idxA
    int idxB
    float pxA
    float pxB
    int timeA
    int timeB

// ---------- 初始化数组,模拟结构体的多个数组 ----------
var openArr  = array.new_float()
var highArr  = array.new_float()
var lowArr   = array.new_float()
var closeArr = array.new_float()
var timeArr  = array.new_int()

// 存储分型信息
var fractalIndexes = array.new_int()
var fractalPrices  = array.new_float()
var fractalTimes   = array.new_int()
var fractalTypes   = array.new_int()  // 顶=1，底=-1

// 当前合并K线状态
var float curOpen  = na
var float curHigh  = na
var float curLow   = na
var float curClose = na
var int   curTime  = na

// ---------- 函数,判断包含关系 ----------
isInside(ph, pl, ch, cl) =>
    (ch <= ph and cl >= pl) or (ch >= ph and cl <= pl)

// 获取方向：向左寻找最近一根非包含K线
getMergeDirection(float curHigh, float curLow) =>
    int len = array.size(highArr)
    int dir = 0
    if len > 0
        for i = len - 1 to 0
            float prevHigh = array.get(highArr, i)
            float prevLow  = array.get(lowArr, i)
            bool notInside = not isInside(prevHigh, prevLow, curHigh, curLow)
            if notInside
                dir := curHigh > prevHigh ? 1 : -1
                break
    dir

// ---------- 合并K线 ----------
if bar_index == 0
    curOpen := open
    curHigh := high
    curLow := low
    curClose := close
    curTime := time
else
    if isInside(curHigh, curLow, high, low)
        dir = getMergeDirection(curHigh, curLow)
        if dir == -1
            curHigh := math.min(curHigh, high)
            curLow := math.min(curLow, low)
        else if dir == 1
            curHigh := math.max(curHigh, high)
            curLow := math.max(curLow, low)
        curClose := close
    else
        // 推入数组
		array.push(openArr, curOpen)
        array.push(highArr, curHigh)
        array.push(lowArr, curLow)
        array.push(closeArr, curClose)
        array.push(timeArr, curTime)

        // 重新初始化
		curOpen := open
        curHigh := high
        curLow := low
        curClose := close
        curTime := time

// ---------- 最后一根合并K线 ----------
if barstate.islast
    array.push(openArr, curOpen)
    array.push(highArr, curHigh)
    array.push(lowArr, curLow)
    array.push(closeArr, curClose)
    array.push(timeArr, curTime)

    // ---------- 识别分型 ----------
    array.clear(fractalIndexes)
    array.clear(fractalPrices)
    array.clear(fractalTimes)
    array.clear(fractalTypes)

    for i = 1 to array.size(openArr) - 2
        float lh = array.get(highArr, i - 1)
        float ch = array.get(highArr, i)
        float rh = array.get(highArr, i + 1)

        float ll = array.get(lowArr, i - 1)
        float cl = array.get(lowArr, i)
        float rl = array.get(lowArr, i + 1)

        int t = array.get(timeArr, i)
        float h = array.get(highArr, i)
        float l = array.get(lowArr, i)

        // 确保三根K线互不包含
		noContain = not isInside(lh, ll, ch, cl) and not isInside(ch, cl, rh, rl)

        if noContain
            isTop = ch > lh and ch > rh and cl > ll and cl > rl
            isDown = ch < lh and ch < rh and cl < ll and cl < rl

            if isTop
                label.new(t, h, "顶", style=label.style_label_down, color=color.rgb(82, 134, 255), textcolor=color.black, xloc=xloc.bar_time)
                array.push(fractalIndexes, i)
                array.push(fractalPrices, h)
                array.push(fractalTimes, t)
                array.push(fractalTypes, 1)

            if isDown
                label.new(t, l, "底", style=label.style_label_up, color=color.rgb(186, 194, 81), textcolor=color.white, xloc=xloc.bar_time)
                array.push(fractalIndexes, i)
                array.push(fractalPrices, l)
                array.push(fractalTimes, t)
                array.push(fractalTypes, -1)

    // ---------- 成笔 ----------
    MIN_GAP = 4
    var penList = array.new<Pen>()
    array.clear(penList)

    if array.size(fractalIndexes) >= 2
        i = 0
        while i < array.size(fractalIndexes) - 1
            idxA = array.get(fractalIndexes, i)
            pxA = array.get(fractalPrices, i)
            timeA = array.get(fractalTimes, i)
            typeA = array.get(fractalTypes, i)

            j = i + 1
            found = false
            while j < array.size(fractalIndexes)
                idxB = array.get(fractalIndexes, j)
                pxB = array.get(fractalPrices, j)
                timeB = array.get(fractalTimes, j)
                typeB = array.get(fractalTypes, j)

                // 获取高低点
                float highA = array.get(highArr, idxA)
                float lowA  = array.get(lowArr, idxA)
                float highB = array.get(highArr, idxB)
                float lowB  = array.get(lowArr, idxB)

                // 新增条件：笔需满足价格有效性
                bool priceValid =
                  (typeA == -1 and typeB == 1 and highB > lowA) or
                  (typeA == 1 and typeB == -1 and lowB < highA) or
                  (typeA == 1 and typeB == 1) or
                  (typeA == -1 and typeB == -1)

                // 判断是否跳过 MIN_GAP：顶分型连顶 or 底分型连底
                bool skipMinGap =
                  (typeA == 1 and typeB == 1) or
                  (typeA == -1 and typeB == -1)

                bool gapEnough = (idxB - idxA >= MIN_GAP) or skipMinGap

                valid =
                  gapEnough and
                  (
                      (typeA == 1 and (typeB == -1 or pxB > pxA)) or
                      (typeA == -1 and (typeB == 1 or pxB < pxA))
                  ) and priceValid

                if valid
                    array.push(penList, Pen.new(idxA, idxB, pxA, pxB, timeA, timeB))
                    color penColor = (typeA == -1 and typeB == -1) or (typeA == 1 and typeB == -1) ? color.blue :
                                     (typeA == 1 and typeB == 1) or (typeA == -1 and typeB == 1) ? color.orange : color.gray
                    line.new(timeA, pxA, timeB, pxB, color=penColor, width=2, xloc=xloc.bar_time)
                    found := true
                    break
                j += 1
            i := found ? j : i + 1

    // ---------- 真笔识别（修复越界） ----------
    var truePenList = array.new<Pen>()
    array.clear(truePenList)

    penCount = array.size(penList)
    if penCount > 0
        int groupStart = 0
        while groupStart < penCount
            Pen startPen = array.get(penList, groupStart)
            int dir = startPen.pxB > startPen.pxA ? 1 : -1
            int groupEnd = groupStart

            // 越界保护
            if groupStart + 1 >= penCount
                array.push(truePenList, startPen)
				//color singleColor = dir == 1 ? color.navy : color.maroon
                //line.new(startPen.timeA, startPen.pxA, startPen.timeB, startPen.pxB, xloc=xloc.bar_time, color=singleColor, width=3)
                break

            // 合并方向一致的成笔
            for i = groupStart + 1 to penCount - 1
                Pen nextPen = array.get(penList, i)
                int nextDir = nextPen.pxB > nextPen.pxA ? 1 : -1
                if nextDir == dir
                    groupEnd := i
                else
                    break

            Pen penStart = array.get(penList, groupStart)
            Pen penEnd   = array.get(penList, groupEnd)
            Pen merged   = Pen.new(penStart.idxA, penEnd.idxB, penStart.pxA, penEnd.pxB, penStart.timeA, penEnd.timeB)
            array.push(truePenList, merged)
			
			//color penColor = dir == 1 ? color.navy : color.maroon
            //line.new(merged.timeA, merged.pxA, merged.timeB, merged.pxB, xloc=xloc.bar_time, color=penColor, width=3)

            groupStart := groupEnd + 1

    // ---------- 中枢识别与延续 ----------
    turepenCount = array.size(truePenList)
    start = 0
    while start <= turepenCount - 3
        Pen p1 = array.get(truePenList, start)
        Pen p2 = array.get(truePenList, start + 1)
        Pen p3 = array.get(truePenList, start + 2)

        float hi1 = math.max(p1.pxA, p1.pxB)
        float lo1 = math.min(p1.pxA, p1.pxB)
        float hi2 = math.max(p2.pxA, p2.pxB)
        float lo2 = math.min(p2.pxA, p2.pxB)
        float hi3 = math.max(p3.pxA, p3.pxB)
        float lo3 = math.min(p3.pxA, p3.pxB)

        float zhHigh = math.min(hi1, hi2, hi3)
        float zhLow  = math.max(lo1, lo2, lo3)

        if zhLow <= zhHigh
            int leftTime = p1.timeA
            int rightTime = p3.timeB
            extendIndex = start + 3
            while extendIndex < turepenCount
                Pen ext = array.get(truePenList, extendIndex)
                float extHi = math.max(ext.pxA, ext.pxB)
                float extLo = math.min(ext.pxA, ext.pxB)

                if extHi < zhLow or extLo > zhHigh
                    break
                zhHigh := math.min(zhHigh, extHi)
                zhLow  := math.max(zhLow, extLo)
                rightTime := ext.timeB
                extendIndex += 1

            box.new(leftTime, zhHigh, rightTime, zhLow, xloc=xloc.bar_time, bgcolor=color.new(color.aqua, 85), border_color=color.new(color.blue, 70))
            start := extendIndex
        else
            start += 1
